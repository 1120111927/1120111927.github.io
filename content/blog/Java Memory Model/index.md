---
title: Java内存模型
date: "2021-03-29"
description: Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。
tags: JMM, 内存间交互操作, 先行发生原则
---

Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。

Java内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性这3个重要特征来建立的，主要目标是定义程序中各个变量[^ 包括实例字段、静态字段和构成数组对象的元素，但不包括局部变量与方法参数，这二者为线程私有，不会被共享，自然不会存在竞争问题]的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。

Java内存模型规定所有的变量都存储在主内存（Main Memory）中，每条线程有自己的工作内存（Working Memory），线程的工作内存中保存了被该线程使用到的变量的主内存副本拷贝，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。

线程、主内存、工作内存三者的交互关系：

```bob-svg
  .-------------.         .----------------.          +------+
  | Java Thread |  <----> | Working Memory |  <---->  |      |
  '-------------'         '----------------'          |      |        .------------.
                                                      | Save |        |            |
  .-------------.         .----------------.          |      |        |    Main    |
  | Java Thread |  <----> | Working Memory |  <---->  | and  | <----> |            |
  '-------------'         '----------------'          |      |        |   Memory   |
                                                      | Load |        |            |
  .-------------.         .----------------.          |      |        '------------'
  | Java Thread |  <----> | Working Memory |  <---->  |      |
  '-------------'         '----------------'          +------+
```

主内存、工作内存与Java运行时数据区域中的堆、栈、方法区等不是同一个层次的内存划分。从变量、主内存、工作内存的定义来看，主内存主要对应于Java堆中的对象实例数据部分，工作内存则对应于虚拟机栈中的部分区域。从更低层次上说，主内存就直接对应于物理硬件的内存，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中。

Java内存模型通过8种内存访问操作、执行操作的规则以及对volatile的特殊规定来确定一个访问在并发环境下是否安全，先行发生（happen-before）原则是它的一个等效判断原则。

## 内存间交互操作

关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存复制到工作内存、如何从工作内存同步回主内存之类的实现细节，Java内存模型定义了以下8种操作[^ 虚拟机实现时必须保证这8种操作都是原子的]来完成：

+ lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占的状态
+ unlock（解锁）：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定
+ read（读取）：作用于主内存的变量，把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用
+ load（载入）：作用于主内存的变量，把read操作从主内存中得到的变量值放入工作内存的变量副本中
+ use（使用）：作用于工作内存的变量，把工作内存中的一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行这个操作
+ assign（赋值）：作用于工作内存的变量，把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作
+ store（存储）：作用于工作内存的变量，把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用
+ write（写入）：作用于主内存的变量，把store操作从工作内存中得到的变量的值放入主内存的变量中

Java内存模型规定了在执行上述8中基本操作时必须满足的规则：

+ 不允许read和load、store和write操作之一单独出现。而且，如果要把一个变量从主内存复制到工作内存，需要顺序执行read和load操作，如果要把一个变量从工作内存同步回主内存，需要顺序执行store和write操作
+ 不允许一个线程丢弃它的最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存
+ 不允许一个线程无原因地把数据从线程的工作内存同步回主内存中
+ 一个新的变量只能在主内存中诞生，即对一个变量实施use、store操作之前，必须先执行过了assign和load操作
+ 一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁
+ 如果对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值
+ 如果一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定住的变量
+ 对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）

volatile变量的特殊规则：

+ volatile变量的read、load、use必须连续执行。这条规则要求在工作内存中，每次使用volatile变量前都必须先从主内存刷新最新的值，用于保证能看见其他线程对volatile变量所做的修改后的值。
+ volatile变量的assign、store、write必须连续执行。这条规则要求在工作内存中，每次修改volatile变量后都必须立刻同步回主内存中，用于保证其他线程可以看到自己对volatile变量所做的修改
+ 如果一个线程对volatile变量A的use或assign动作先于其对volatile变量B的use或assign动作，那么该线程对volatile变量A的read或write动作也先于其对volatile变量B的read或write动作。这条规则要求volatile变量不会被指令重排序优化，保证代码的执行顺序与程序的顺序相同

对long和double变量的特殊规则，即long和double的非原子性协定（Nonatomic Treatment of double and long Variables），对于64位数据类型（long和double），允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性[^ 同时也允许且强烈建议虚拟机把这些操作实现为具有原子性的操作，目前商用Java虚拟机都选择把64位数据的读写操作作为原子操作来对待]。

## 原子性、可见性与有序性

原子性（Atomicity）：由Java内存模型来直接保证的原子性变量操作包括read、load、assign、use、store和write，可以认为基本数据类型的访问读写是具备原子性的。另外，Java内存模型还提供了lock和unlockp[^ 用户不可直接使用]操作来提供更大范围的原子性保证，字节码指令monitorenter和monitorexit隐式地使用这两个操作，这两个指令对应Java代码中的同步块--synchronized关键字，即synchronized块之间地操作也具备原子性

可见性（Visibility）：是指当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。Java内存模型通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性。Java提供了volatile、synchronized和final 3个关键字来保证可见性。volatile变量的特殊规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新；synchronized块的可见性是由规则--对一个变量执行unlock操作之前，必须先把此变量同步回主内存中--获得的；final关键字可见性是指被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把this的引用传递出去[^ this引用逃逸]，那在其他线程中就能看见final字段的值

有序性（Ordering）：Java内存模型的有序性是指线程内表现为串行的语义（Within-Thread As-If-Serial Semantics），即如果在本线程内观察，所有的操作都是有序的。由于指令重排序现象和工作内存与主内存同步延迟现象，如果在一个线程中观察另一个线程，所有的操作都是无序的。Java提供了volatile和synchronized两个关键字来保证线程之间操作的有序性。volatile关键字本身就包含了禁止指令重排序的语义；synchronized块的有序性是由规则--一个变量在同一个时刻只允许一条线程对其进行lock操作--获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入

## 先行发生原则

先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，操作A产生的影响（修改了内存中共享变量的值、发送了消息、调用了方法等）能被操作B观察到。先行发生原则是判断数据是否存在竞争、线程是否安全的主要依据。

+ 程序次序规则（Program Order Rule）：在一个线程内，按照控制流顺序，前面的操作先行发生于后面的操作，即线程内表现为串行
+ 管程锁定规则（Monitor Lock Rule）：一个unlock操作先行发生于后面对同一个锁的lock操作，“后面”是指时间上的先后顺序
+ volatile变量规则（Volatile Variable Rule）：对一个volatile变量的写操作先行发生于后面对这个变量的读操作，“后面”是指时间上的先后顺序
+ 线程启动规则（Thread Start Rule）：Thread对象的start()方法先行发生于此线程的每一个动作
+ 线程终止规则（Thread Termination Rule）：线程中的所有操作都先行发生于对此线程的终止检测
+ 线程中断规则（Thread Interruption Rule）：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生
+ 对象终结规则（Finalizer Rule）：一个对象的初始化完成（构造函数执行结束）先行发生于它的finalize()方法的开始
+ 传递性（Transitivity）：如果操作A先行发生于操作B，操作B先行发生于操作C，则操作A先行发生于操作C

如果两个操作之间的关系不是上面几种，并且无法从这些规则推导出来，它们就没有顺序性保障，虚拟机可以对它们随意地进行重排序。

缓存机制、处理器的乱序执行以及JVM的指令重排序导致时间先后顺序与先行发生基本没有太大的关系，衡量并发安全问题的时候不要受到时间顺序的干扰，一切必须以先行发生原则为准。
