---
title: 关系查询语言
date: "2020-04-19"
description: 查询语言（query language）是用户用来从数据库中请求获取信息的语言，比标准的程序设计语言层次更高。
tags: 关系查询语言，关系代数，元组关系演算，域关系演算
---

查询语言可以分为过程化和非过程化的。在过程化语言（procedural language）中，用户指导系统对数据库执行一系列操作以计算出所需结果。在非过程化语言（nonprocedural language）中，用户只需描述所需信息，而不用给出获取该信息的具体过程。实际使用的查询语言既包含过程化方式的成分，又包含非过程化方式的成分。

有一些“纯”查询语言：关系代数是过程化的（提供了产生查询结果的过程序列，这个序列能生成查询的答案），元组关系演算和域关系演算是非过程化的（只描述所需信息，而不给出获得该信息的具体过程）。关系代数是SQL查询语言的基础，元组关系演算和域关系演算都是基于数学逻辑的声明式查询语言。

下述三者的表达能力是等价的：

+ 基本关系代数（不包括扩展关系代数运算）

+ 限制在安全表达式范围内的元组关系演算

+ 限制在安全表达式范围内的域关系演算

没有任何一个元组关系演算或域关系演算等价于聚集运算，但是可以扩展元组关系演算或域关系演算以支持聚集。

## 关系代数（relational algebra）

关系代数是一种过程化查询语言，定义了一组在关系上的代数运算，被称为关系代数运算。这些运算以一个或两个关系为输入，产生一个新的关系作为结果。这些运算也可以混合使用来得到表达所希望查询的表达式。关系代数运算是关系查询语言中使用的基本运算。

关系代数运算可以分为：

+ 基本运算：包括选择、投影、并、集合差、笛卡尔积和更名

+ 附加的关系代数运算：可以用基本运算表达，不能增强关系代数的表达能力，用于简化常用查询。包括集合交、自然连接、赋值、外连接

+ 扩展的关系代数运算：实现了一些不能用基本的关系代数运算来表达的查询，包括广义投影、聚集

多个关系代数运算组合成一个关系代数表达式（relational-algebra expression）。

### 基本运算

关系代数的基本运算足以表达任何关系代数查询。

|运算|描述|符号|备注|
|---|---|---|---|
|选择（select）|返回输入关系中满足给定谓词的元组|$\sigma_{predicate}(relation)$|+ 允许在选择谓词中使用$=$、$\ne$、$<$、$\leqslant$、$>$和$\geqslant$进行比较<br>+ 可以用连词`and`（$\land$）、`or`（$\lor$）和`not`（$\lnot$）将多个谓词合并为一个较大的谓词<br>+ 选择谓词中可以包括两个属性的比较|
|投影（project）|对输入关系的所有行输出指定的属性，从输出中去除重复元组|$\Pi_{attributes}(relation)$||
|并（union）|输出两个输入关系中元组的并|$r1\cup r2$|必须保证做并运算的关系是相容的|
|集合差（set-difference）|输出在一个关系中而不在另一个关系中的元组|$r1 - r2$|必须保证做集合差运算的关系是相容的|
|笛卡尔积（cartesian-product）|从两个输入关系中输出所有的元组对（无论它们在共同属性上的取值是否相同）|$r1 \times r2$||
|更名（rename）|重命名输入关系（及其属性）|$\rho_{x}(relation)$<br>$\rho_{x(attributes)}(relation)$||

如果关系r和s是同元的（即它们的属性数目相同），且对所有的i，r的第i个属性的域和s的第i个属性的域相同，则称关系r和s是相容的。

### 附加的关系代数运算

|运算|描述|符号|备注|
|---|---|---|---|
|集合交（intersection）|输出两个关系中相同的元组|$r1 \cap r2$|必须保证做集合交运算的两个关系是相容的。<br>等价于$r1 - (r1-r2)$|
|自然连接（nature join）|从两个输入关系中输出这样的元组对：它们在具有相同名字的所有属性上取值相同|$r1 \bowtie r2$|自然连接运算首先形成它的两个参数的笛卡尔积，然后基于两个关系模式中都出现的属性上的相等性进行选择，最后还要去除重复属性<br>自然连接是可结合的（associative）|
|theta连接|输出两个输入关系的笛卡尔积中满足给定谓词的元组|$r1 \bowtie_{\theta} r2$<br>（$\theta$是两个输入关系属性上的谓词）|theta连接是自然连接的扩展，可以把一个选择运算和一个笛卡尔积运算合并为单独的一个运算<br>等价于$\sigma_{\theta}(r1 \times r2)$|
|赋值（assignment）|将关系赋给临时关系变量|$ variable \leftarrow relation$|对于关系代数查询，赋值必须是赋给一个临时关系变量。对永久关系的赋值形成了对数据库的修改<br>使用赋值运算，可以把查询表达为一个顺序程序，该程序由一系列赋值加上一个其值被作为查询结果显示的表达式组成|
|左外连接（left outer join）|取出左侧关系中所有与右侧关系的任一元组都不匹配的元组，用空值填充所有来自右侧关系的属性，再把产生的元组添加到自然连接的结果中|$r1 ⟕ r2$|等价于<br>$(r1 \bowtie r2) \cup (r1 - \Pi_{R1}(r1 \bowtie r2)) \times \{(null, \dots, null)\}$<br>其中<br>R1是输入关系r1的模式<br>常数关系$\{(null, \dots, null)\}$的模式是R2-R1（R2为输入关系r2的模式）|
|右外连接（right outer join）|用空值填充来自右侧关系的所有与左侧关系的任一元组都不匹配的元组，将结果添加到自然连接的结果中|$r1 ⟖ r2$|等价于<br>$(r1 \bowtie r2) \cup (r2 - \Pi_{R2}(r1 \bowtie r2)) \times \{(null, \dots, null)\}$<br>其中<br>R2是输入关系r2的模式<br>常数关系$\{(null, \dots, null)\}$的模式是R1-R2（R1为输入关系r1的模式）|
|全外连接（full outer join）|既填充左侧关系中与右侧关系的任一元组都不匹配的元组，又填充右侧关系中与左侧关系的任一元组都不匹配的元组，并把结果都加到连接的结果中|$r1 ⟗ r2$||

考虑两个关系模式R和S，用$R \cap S$表示同时出现在R和S中的属性名，用$R \cup S$表示出现在R中或S中或在二者中都出现的属性名，用$R - S$表示出现在R中而不出现在S中的属性名，用$S - R$表示出现在S中而不出现在R中的属性名。则**自然连接的形式化定义**可以描述为：设$r(R)$和$s(S)$是两个关系，r和s的自然连接表示为$r \bowtie s$，是模式$R \cup S$上的一个关系，其形式化定义如下：
$$
r \bowtie s = \Pi_{R \cup S}(\sigma_{r.A_1 = s.A_1 \land r.A_2 = s.A_2 \land \dots \land r.A_n = s.A_n(r \times s)})
$$
其中，$R \cap S = \{A_1, A_2, \dots, A_n\}$。

如果关系r(R)和s(S)不含有任何相同属性，即 $R \cap S = \varnothing $，那么$r \bowtie s = r \times s$。

外连接（outer join）运算是连接运算的扩展，可以处理缺失的信息。外连接运算有三种形式：左外连接、右外连接和全外连接。这三种形式的外连接都要计算连接，然后在连接结果中添加额外的元组。

### 扩展的关系代数运算（extened relational-algebra）

|运算|描述|符号|备注|
|---|---|---|---|
|广义投影（generalizd-projection）|通过允许在投影列表中使用算数运算和字符串函数等来对投影进行扩展|$\Pi_{F_1, F_2, \dots, F_n}(relation)$<br>E是任意关系代数表达式，而$F_1$、$F_2$、$\dots$、$F_n$中的每一个都是涉及常量以及E的模式中属性的算术表达式|最基本的情况下，算术表达式可以仅仅是一个属性或常量|
|聚集（aggregate）|用来对值的集合使用聚集函数|${}_{G_1,G_2,\dots,G_n}\mathcal{G}_{F_1(A_1),F_2(A_2),\dots,F_m(A_m)}(relation)$<br>$G_1, G_2, \dots, G_n$是用于分组的一系列属性<br>每个$F_i$是一个聚集函数<br>每个$A_i$是一个属性名|运算的含义如下，表达式E的结果中元组以如下方式被分成若干组：<br>+ 同一组中所有元组在$G_1, G_2, \dots, G_n$上的值相同<br>+ 不同组中元组在$G_1, G_2, \dots, G_n$上的值不同<br>因此，各组可以用属性$G_1, G_2, \dots, G_n$上的值来唯一标识。对每个组$(g_1, g_2, \dots, g_n)$来说，结果中有一个元组$(g_1, g_2, \dots, g_n, a_1, a_2, \dots, a_m)$，其中对每个i，$a_i$是将聚集函数$F_i$作用于该组的属性$A_i$上的多重值集所得到的结果<br>作为聚集运算的特例，属性列$G_1, G_2, \dots, G_n$可以是空的，在这种情况下，会有唯一一组包含关系中所有的元组，相当于没有分组|

聚集函数（aggregate function）是输入值的一个汇集，将单一值作为结果返回。

使用聚集函数对其进行操作的汇集中，一个值可以出现多次，值出现的顺序是无关紧要的。这样的汇集称为多重集（multiset）。集合是多重集的特例，其中每个值都只出现依次。

### 关系代数的形式化定义

关系代数中基本的表达式是如下二者之一：

+ 数据库中的一个关系

+ 一个常数关系。常数关系可以用在`{}`内列出它的元组来表示

关系代数中一般的表达式是由更小的子表达式构成的。设$E_1$和$E_2$是关系代数表达式，则以下这些都是关系代数表达式：

+ $E_1 \cup E_2$

+ $E_1 - E_2$

+ $E_1 \times E_2$

+ $\sigma_P(E_1)$，其中P是$E_1$的属性上的谓词

+ $\Pi_S(E_1)$，其中S是$E_1$中某些属性的列表

+ $\rho_x(E_1)$，其中x是$E_1$结果的新名字

<div style="display:none">
### SQL与关系代数

sql允许在输入关系以及查询结果中存在元组的多重拷贝，为了映射sql的这种模式，定义多重集关系代数来对多重集（即存在重复的集合）进行操作。
多重关系代数的基本运算有如下定义：

1. 如果$r_1$中元组$t_1$有$c_1$份拷贝，并且$t_1$满足选择$\sigma_\theta$，那么$\sigma_\theta(r_1)$中元组$t_1$有$c_1$份拷贝
2. 对于$r_1$中元组$t_1$的每份拷贝，在$\Pi_A(r_1)$中都有一个与之对应的$\Pi_A(t_1)$，$\Pi_A(t_1)$表示单个元组$t_1$的投影
3. 如果在$r_1$中元组$t_1$有$c_1$份拷贝，在$r_2$中元组$t_2$有$c_2$份拷贝，那么在$r_1 \times r_2$中就有元组$t_1 \cdot t_2$的$c_1 \ast c_2$份拷贝

TODO

并

交

集合差

```sql
select A1, A2, ..., An
from r1, r2, ..., rm
where P
```

等价于

$$
\Pi_{A_1, A_2, \dots, A_n}(\sigma_P(r_1 \times r_2 \times \dots \times r_m))
$$

```sql
select A1, A2, sum(A3)
from r1, r2, ..., rm
where P
group by A1, A2
```

等价于

$$
{}_{A_1, A_2}\mathcal{G}_{sum(A_3)}(\Pi_{A_1,A_2,\dots,A_n}(\sigma_P(r_1 \times r2 \times \dots r_m)))
$$

</div>

## 元组关系演算（tuple relational calculus）

元组关系演算表达式具有如下形式：

$$
\{t|P(t)\}
$$

其中P是一个公式。公式中可以出现多个元组变量。如果元组变量不被$\exists$或$\forall$修饰，则称为自由变量。

元组关系演算的公式由原子构成。原子可以是如下的形式之一：

+ $s \in r$，其中s是元组变量而r是关系

+ $s[x] \Theta u[y]$，其中s和u是元组变量，x是s所基于的关系模式中的一个属性，y是u所基于的关系模式中的一个属性，$\Theta$是比较运算符（$\lt$、$\leqslant$、$=$、$\ne$、$\gt$、$\geqslant$）；要求属性x和y所属域的成员能用$\Theta$比较

+ $s[x] \Theta c$，其中s是元组变量，x是s所基于的关系模式中的一个属性，$\Theta$是比较运算符，c是属性x所属域中的常量

根据如下规则，用原子构造公式：

+ 原子是公式

+ 如果$P_1$是公式，那么$\neg P_1$和$(P_1)$也都是公式

+ 如果$P_1$和$P_2$是公式，那么$P_1 \lor P_2$、$P_1 \land P_2$和$P_1 \Rightarrow P_2$也都是公式

+ 如果$P(s)$是包含自由元组变量s的公式，且r是关系，则$\exists s \in r(P_1(s))$和$\forall s \in r(P_1(s))$也都是公式

存在结构：$\exists t \in r(Q(t))$，表示关系r中存在元组t使谓词$Q(t)$为真。

对所有的结构：$\forall t \in r(Q(t))$，表示对关系r中所有元组t，Q均为真。

在元组关系演算中，有以下三条等价规则：

1. $P_1 \land P_2$等价于$\neg(\neg(P_1) \lor \neg(P_2))$
2. $\forall t \in r(P_1(t))$等价于$\neg \exists t \in r(\neg P_1(t))$
3. $P_1 \Rightarrow P_2$等价于$\neg(P_1) \lor P_2$

元组关系公式P的域（domain）：记作$dom(P)$，表示P所引用的所有值的集合，既包括P自身用到的值，又包括P中涉及的关系的元组中出现的所有值。即P的域是P中显式出现的值及名称出现在P中的那些关系的所有值的集合。

如果出现在表达式$\{t|P(t)\}$结果中的所有值均来自$dom(P)$，则称表达式$\{t|P(t)\}$是安全的。

不安全的表达式中的元组个数是无限的，而安全的表达式一定包含有限的结果。因此限定只有安全的元组关系演算表达式才被认为是允许的。

## 域关系演算（domain relational calculus）

域关系演算使用从属性域中取值的域变量，而不是整个元组的值，是QBE语言的基础理论。

域关系演算中的表达式形式如下：

$$
\left\{\left< x_1, x_2, \dots, x_n \right>|P\left(x_1, x_2, \dots, x_n\right)\right\}
$$

其中$x_1, x_2, \dots, x_n$代表域变量。P代表由原子构成的公式。域关系演算中的原子具有如下形式之一：

+ $\left< x_1, x_2, \dots, x_n \right> \in r$，其中r是n个属性上的关系，而$x_1, x_2, \dots, x_n$是域变量或域常量
+ $x \Theta y$，其中x和y是域变量，而$\Theta$是比较运算符（$\lt$、$\leqslant$、$=$、$\ne$、$\gt$、$\geqslant$），要求属性x和y所属域可用$\Theta$比较
+ $x \Theta c$，其中x是域变量，$\Theta$是比较运算符，而c是x作为域变量的那个属性域中的常量

根据以下规则，用原子构造公式：

+ 原子是公式
+ 如果$P_1$是公式，那么$\neg P_1$和$\left(P_1\right)$也都是公式
+ 如果$P_1$和$P_2$是公式，那么$P_1 \lor P_2$，$P_1 \land P_2$和$P_1 \Rightarrow P_2$也都是公式
+ 如果$P_1\left(x\right)$是x的一个公式，其中x是自由域变量，则 $\exists x \left(P_1\left(x\right)\right)$和$\forall x\left(P_1\left(x\right)\right)$也都是公式

把$\exists a, b, c \left(P\left(a, b, c\right)\right)$作为$\exists a \left( \exists b \left( \exists c \left(P\left(a, b, c\right)\right)\right)\right)$的简写

如果下列条件同时成立，认为表达式

$$
\left\{ \left< x_1, x_2, \dots, x_n \right> | P\left(x_1, x_2, \dots, x_n\right)\right\}
$$

是安全的：

1. 表达式的元组中所有值均来自$dom(P)$
2. 对每个形如$\exists x \left(P_1\left(x\right)\right)$的“存在”子公式而言，子公式为真当且仅当在$dom(P_1)$中有某个值x使$P_1\left(x\right)$为真
3. 对每个形如$\forall x \left(P_1\left(x\right)\right)$的“对所有的”子公式而言，子公式为真当且仅当$P_1\left(x\right)$对$dom\left(P_1\right)$中所有值x均为真
