---
title: Java垃圾收集器
date: "2021-03-22"
description: 程序计数器、虚拟机栈、本地方法栈3个区域的内存分配和回收都具备确定性，当方法结束或线程结束时，内存自然跟随着回收，不需要过多考虑回收的问题。而由于只有在程序处于运行期间才能知道会创建哪些对象，Java堆和方法区区域的内存分配和回收都是动态的，垃圾收集器关注的是这部分内存。
tags: 引用计数法, 可达性分析算法, 标记-清除算法, 复制算法, 标记-整理算法, 分代收集算法, Serial收集器, ParNew收集器, Parallel Scavenge收集器, Serial Old收集器, CMS收集器, G1收集器
---

GC需要完成3件事情：

+ 哪些内存需要回收？（程序计数器、虚拟机栈、本地方法栈不需要回收，Java堆和方法区需要回收）
+ 什么时候回收？（通过引用计数法判断对象的引用数量或可达性分析算法判断对象的引用链是否可达来确定对象是否存活）
+ 如何回收？（垃圾收集算法是内存回收地方法论，垃圾收集器是内存回收的具体实现）

程序计数器、虚拟机栈、本地方法栈3个区域的内存分配和回收都具备确定性，当方法结束或线程结束时，内存自然跟随着回收，不需要过多考虑回收的问题。而由于只有在程序处于运行期间才能知道会创建哪些对象，Java堆和方法区区域的内存分配和回收都是动态的，垃圾收集器关注的是这部分内存。

## 对象存活判断算法

有两种方法确定堆中不可能再被任何途径使用的对象：

+ 引用计数算法（Reference Counting）：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。引用计数法很难解决对象之间相互循环引用的问题

+ 可达性分析算法（Reachability Analysis）：通过GC Roots作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain）。当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。可达性分析存在两个问题：一个是在Java语言中，可作为GC Roots的节点主要在全局性的引用（方法区中类静态属性引用的对象、方法区中常量引用的对象）与执行上下文（虚拟机栈栈帧中的本地变量表中引用的对象、本地方法栈中JNI（Native方法）引用的对象）中，逐个检查这些引用会消耗很多时间；另一个是GC停顿，可达性分析必须在一个能确保一致性的快照中进行（一致性是指在分析过程中整个执行系统不可以出现对象引用关系不断变化的情况，否则分析结果的准确性无法得到保证），这点是导致GC进行时必须停顿所有Java执行线程（Stop The World）的其中一个重要原因

Java虚拟机规范不要求虚拟机在方法区实现垃圾收集。HotSpot虚拟机中垃圾收集主要回收两部分内容：废弃常量和无用的类。

废弃常量常量池中没有对象引用的常量。

类需要同时满足下面3个条件才能算是无用的类：

+ 该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例
+ 加载该类的ClassLoader已经被回收
+ 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

HotSpot虚拟机提供了`-Xnoclassgc`参数控制是否对类进行回收，还可以使用`-verbose:clas`、`-XX:+TraceClassLoading`、`-XX:+TraceClassUnLoading`查看类加载和卸载信息。

在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载功能，以保证永久代不会溢出。

### 引用

JDK 1.2以前，Java中引用的定义：如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。这种定义下，一个对象只有被引用或者没有被引用两种状态。为了描述这样一种对象：当内存空间还足够时，则能保留在内存中；如果内存空间在进行垃圾收集后还是非常紧张，则可以抛弃这些对象。（很多系统的缓存功能都符合这样的应用场景。）JDK 1.2之后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用4种，这4种引用强度依次逐渐减弱。

+ 强引用（Strong Reference）：是最传统的引用的定义，指程序代码中普遍存在的引用赋值，如`Object obj = new Object()`。只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象
+ 软引用（Soft Reference）：用来描述一些还有用但并非必需的对象，SoftReference类用于实现软引用。对于软引用关联着的对象，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。
+ 弱引用（Weak Reference）：用来描述非必需对象，强度比软引用更弱一些，WeakReference类用于实现弱引用。被弱引用关联的对象只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
+ 虚引用（Phantom Reference）：也称幽灵引用或幻影引用，是最弱的一种引用关系，PhantomReference类用于实现虚引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用的唯一目的就是能在这个对象被收集器回收时收到一个系统通知

## 垃圾收集算法

**标记-清除（Mark-Sweep）算法**：最基础的收集算法，分为标记和清除两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作

**复制（Copying）算法**：将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。优点是内存分配时不用考虑内存碎片等复杂情况，只要移动堆指针，按顺序分配内存即可，缺点是将内存缩小为原来的一半，代价过高

**标记-整理（Mark-Compact）算法**：首先标记出所有需要回收的对象，接着让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存

**分代收集（Generational Collection）算法**：根据对象存活周期的不同将内存划分为几块，一般是把Java堆分为新生代和老年代，根据各个年代的特点采用最适当的收集算法，在新生代中使用复制算法，在老年代中使用标记-清除或标记-整理算法。当前商业虚拟机的垃圾收集都采用分代收集算法。

新生代中的对象98%都是生命周期短，不需要按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor地大小比例是8:1。当Survivor空间不够时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion），即如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。

Minor GC是指新生代GC，即发生在新生代的垃圾收集动作，Major GC或Full GC是指老年代GC，即发生在老年代的垃圾收集动作，Major GC的速度一般会比Minor GC慢10倍以上。

**分配担保机制** 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC；如果小于，或者HandlePromotionFailture设置不允许冒险，则需要改为进行一次Full GC。JDK 6 update 24之后的规则，变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则进行Full GC。

## HotSpot垃圾收集算法实现

**枚举根节点** HotSpot通过OopMap、安全点（Safepoint）、安全区域（SafeRegion）来快速且准确地完成GC Roots枚举。

下图展示了7种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用。虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器:

```bob-svg
+----------------------------------------------+
|                             Young generation |
|                                              |
|             +-------+ +--------+             |
|  +--------+ |ParNew | |Parallel|             |
|  | Serial | +---+---+ |Scavenge|             |
|  +----+---+    /|     +---+----+             |
|       |\      / |        / \                 |
|       | \    /  |       /   \        +----+  |
|-------|--\--/---|------/-----\-------| G1 |--|
|       |   \/    |     /       \      +----+  |
|       |   /\    |    /    +----+---+         |
|      ++--+-+\   |   /     |Parallel|         |
|      | CMS | \  |  /      |  Old   |         |
|      +--+--+  \ | /       +--------+         |
|          \     \|/                           |
|           +-----+-----+                      |
|           + Serial Old|                      |
|           +-----------+   Tenured generation |
|                                              |
+----------------------------------------------+
```

Serial/Serial Old收集器运行示意图：

```bob-svg
       user thread 1  |                   !              |                         !
CPU0 ~~~~~~~~~~~~~~~~>|                   !~~~~~~~~~~~~~>|                         !~~~~~~~~~~~~~>
       user thread 2  |     GC thread     !              |    GC thread            !
CPU1 ~~~~~~~~~~~~~~~~>|------------------>!~~~~~~~~~~~~~>|------------------------>!~~~~~~~~~~~~~>
       user thread 3  | 新生代采用复制算法!              | 老年代采取标记-整理算法 !
CPU2 ~~~~~~~~~~~~~~~~>| 暂停所有用户线程  !~~~~~~~~~~~~~>| 暂停所有用户线程        !~~~~~~~~~~~~~>
       user thread 4  |                   !              |                         !
CPU3 ~~~~~~~~~~~~~~~~>|                   !~~~~~~~~~~~~~>|                         !~~~~~~~~~~~~~>
                      |                   !              |                         !
                  Safepoint                          Safepoint
```

ParNew/Serial Old收集器运行示意图：

```bob-svg
       user thread 1  |     GC thread 1   !              |                         !
CPU0 ~~~~~~~~~~~~~~~~>|------------------>!~~~~~~~~~~~~~>|                         !~~~~~~~~~~~~~>
       user thread 2  |     GC thread 2   !              |       GC thread         !
CPU1 ~~~~~~~~~~~~~~~~>|------------------>!~~~~~~~~~~~~~>|------------------------>!~~~~~~~~~~~~~>
       user thread 3  |     GC thread 3   !              |老年代采取标记-整理算法  !
CPU2 ~~~~~~~~~~~~~~~~>|------------------>!~~~~~~~~~~~~~>|暂停所有用户线程         !~~~~~~~~~~~~~>
       user thread 4  | 新生代采用复制算法!              |                         !
CPU3 ~~~~~~~~~~~~~~~~>| 暂停所有用户线程  !~~~~~~~~~~~~~>|                         !~~~~~~~~~~~~~>
                      |                   !              |                         !
                  Safepoint                          Safepoint
```

Parallel Scanvenge/Parallel Old收集器运行示意图：

```bob-svg
      user thread 1  |   GC thread 1    !              |    GC thread 1   !
CPU0 ~~~~~~~~~~~~~~~>|----------------->!~~~~~~~~~~~~~>|----------------->!~~~~~~~~~~~~~>
      user thread 2  |   GC thread 2    !              |    GC thread 2   !
CPU1 ~~~~~~~~~~~~~~~>|----------------->!~~~~~~~~~~~~~>|----------------->!~~~~~~~~~~~~~>
      user thread 3  |   GC thread 3    !              |    GC thread 3   !
CPU2 ~~~~~~~~~~~~~~~>|----------------->!~~~~~~~~~~~~~>|----------------->!~~~~~~~~~~~~~>
      user thread 4  |   GC thread 4    !              |    GC thread 4   !
CPU3 ~~~~~~~~~~~~~~~>|----------------->!~~~~~~~~~~~~~>|----------------->!~~~~~~~~~~~~~>
                     |                  !              |                  !
                 Safepoint                         Safepoint
```

CMS收集器运行示意图：

```bob-svg
       user thread 1  |               ! user thread 1   |   remark   !   user thread 1   ! user thread 1
CPU0 ~~~~~~~~~~~~~~~~>|               !~~~~~~~~~~~~~~~~>|----------->!~~~~~~~~~~~~~~~~~~>!~~~~~~~~~~~~~~~~~~~~~~~~>
       user thread 2  | initial mark  ! user thread 2   |   remark   !   user thread 2   ! user thread 2
CPU1 ~~~~~~~~~~~~~~~~>|-------------->!~~~~~~~~~~~~~~~~>|----------->!~~~~~~~~~~~~~~~~~~>!~~~~~~~~~~~~~~~~~~~~~~~~>
       user thread 3  |               ! concurrent mark |   remark   ! concurrent sweep  ! reset thread 
CPU2 ~~~~~~~~~~~~~~~~>|               !---------------->|----------->!------------------>!--------------->!~~~~~~~>
       user thread 4  |               ! user thread 4   |   remark   !   user thread 4   ! user thread 4
CPU3 ~~~~~~~~~~~~~~~~>|               !~~~~~~~~~~~~~~~~>|----------->!~~~~~~~~~~~~~~~~~~>!~~~~~~~~~~~~~~~~~~~~~~~~>
                      |               !                 |            !                   !
                  Safepoint       Safepoint         Safepoint    Safepoint           Safepoint
```

G1收集器运行示意图：

```bob-svg
       user thread 1  |               ! user thread 1   |   final mark   ! live data counting and evacuation  !  user thread 1
CPU0 ~~~~~~~~~~~~~~~~>|               !~~~~~~~~~~~~~~~~>|--------------->!----------------------------------->!~~~~~~~~~~~~~~~~~>
       user thread 2  | initial mark  ! user thread 2   |   final mark   ! live data counting and evacuation  !  user thread 2
CPU1 ~~~~~~~~~~~~~~~~>|-------------->!~~~~~~~~~~~~~~~~>|--------------->!----------------------------------->!~~~~~~~~~~~~~~~~~>
       user thread 3  |               ! concurrent mark |   final mark   ! live data counting and evacuation  !  user thread 3
CPU2 ~~~~~~~~~~~~~~~~>|               !---------------->|--------------->!----------------------------------->!~~~~~~~~~~~~~~~~~>
       user thread 4  |               ! user thread 4   |   final mark   ! live data counting and evacuation  !  user thread 4
CPU3 ~~~~~~~~~~~~~~~~>|               !~~~~~~~~~~~~~~~~>|--------------->!----------------------------------->!~~~~~~~~~~~~~~~~~>
                      |               !                 |                !                                    !                  
                  Safepoint       Safepoint         Safepoint        Safepoint                            Safepoint
```

**Serial收集器**：是最基本、发展历史最悠久的收集器，是一个单线程收集器，只会使用一个CPU或一条收集线程去完成垃圾收集工作，在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。优点是简单而高效（与其他收集器的单线程比），适用于单CPU环境，是虚拟机运行在Client模式下的默认新生代收集器

**ParNew收集器**：Serial收集器的多线程版本，是虚拟机运行在Server模式下的首选新生代收集器，当使用CMS来收集老年代的时候，新生代只能选择ParNew或者Serial收集器中的一个，ParNew也是使用-XX:+UseConcMarkSweepGC选项后的默认新生代收集器，也可以使用-XX:+UseParNewGC选项强制指定它。ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果（甚至由于存在线程交互的开销，该收集器在通过超线程技术实现的两个CPU环境中都不能百分之百保证可以超越Serial收集器），随着可以使用的CPU数量的增加，对于GC时系统资源的有效利用还是很有好处的，默认开启的收集线程数与CPU的数量相同，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数

**Parallel Scavenge收集器**：是使用复制算法的并行的多线程的新生代收集器，目标是达到一个可控制的吞吐量（Throughput），吞吐量指CPU用于用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间)，高吞吐量可以高效地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间地-XX:MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX:GCTimeRatio参数。另外，参数-XX:+UseAdaptiveSizePolicy控制自适应调节策略开关，指定自适应调节后，就不需要手动指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量

+ MaxGCPauseMillis参数允许的值是一个大于0的毫秒数，收集器将尽可能地保证内存回收花费的时间不超过设定值，GC停顿时间缩短是以牺牲吞吐量和新生代空间来换取的
+ GCTimeRatio参数的值应当是一个大于0且小于100的整数，是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数

**Serial Old收集器**：是Serial收集器的老年代版本，同样是一个单线程收集器，使用标记-整理算法，主要应用于Client模式下的虚拟机。在Server模式下有两大用途：一是在JDK 1.5及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用

**Parallel Old收集器**：是Parallel Scavenge收集器的老年代版本，使用多线程和标记=整理算法，在JDK 1.6中才开始提供。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器

**CMS收集器**：Concurrent Mark Sweep，目标是获取最短回收停顿时间，符合互联网网站或者B/S系统的服务端等应用重视服务响应速度、希望系统停顿时间最短的需求，基于标记-清除算法实现，运作过程分为4个步骤：初始标记（CMS initial mark）、并发标记（CMS concurrent mark）、重新标记（CMS remark）、并发清除（CMS concurrent sweep）。其中，初始标记、重新标记这两个步骤仍然需要STW，初始标记阶段标记GC Roots能直接关联到的对象，并发标记阶段进行GC Roots Tracing，重新标记阶段修正并发标记期间因用户程序继续运作而导致标记产生变动的那部分对象的标记记录。整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，从整体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。优点是并发收集、低停顿，缺点是对CPU资源非常敏感、无法处理浮动垃圾（Floating Garbage）、收集结束时会有大量空间碎片产生。

**G1收集器**：Garbage-First，是一款面向服务端应用的垃圾收集器，从整体上看是基于标记-整理算法，从局部（两个Region之间）上看是基于复制算法，使用Region划分内存空间以及有优先级的区域回收方式，运作过程分为4个步骤：初始标记（Initial Marking）、并发标记（Concurrent Marking）、最终标记（Final Marking）、筛选回收（Live Data Counting and Evacuation），优点是并行与并发、分代收集、空间整合、可预测的停顿。

**直到现在为止还没有最好的收集器出现，更加没有万能的收集器，只有根据实际应用需求、实现方式选择最优的收集方式（考虑每个收集器的行为、优势和劣势、调节参数）才能获取最高的性能。**

### CMS收集器

### G1收集器

#### Remembered Set

虚拟机使用Remembered Set处理G1收集器中Region之间的对象引用以及其他收集器中的新生代与老年代之间的对象引用。

## GC日志

## 内存分配

内存分配规则取决于使用的垃圾收集器组合，还有虚拟机中与内存相关的参数的设置。

几条最普遍的内存分配原则：

+ 对象优先在Eden分配
+ 大对象直接进入老年代
+ 长期存活的对象将进入老年代：虚拟机给每个对象定义了一个对象年龄（Age）计数器，如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1，对象在Survivor区中每经历一次Minor GC，年龄就增加1，当它的年龄增加到一定程度（由参数MaxTenuringThreshold设置，默认为15），就将会被晋升到老年代中
+ 动态年龄判定：如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄
+ 空间分配担保：Minor GC后Survivor无法容纳的对象直接进入老年代

## 垃圾收集器参数

|参数|描述|
|:---:|:---:|
|UseSerialGC|虚拟机运行在Client模式下的默认值，使用Serial+Serial Old收集器组合进行内存回收|
|UseParNewGC|使用ParNew+Serial Old收集器组合进行内存回收|
|UseConcMarkSweepGC|使用ParNew+CMS+Serial Old收集器组合进行内存回收，Serial Old收集器作为CMS收集器出现Concurrent Mode Failure失败后的后备收集器使用|
|UseParallelGC|虚拟机运行在Server模式下的默认值，使用Parallel Scavenge+Serial Old（PS MarkSweep）收集器组合进行内存回收|
|UseParallelOldGC|使用Parallel Scavenge+Parallel Old收集器组合进行内存回收|
|SurvivorRatio|新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1|
|PretenureSizeThreshold|直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配|
|MaxTenuringThreshold|晋升到老年代的对象年龄，每个对象在坚持过一次Minor GC之后，年龄就增加1，当超过这个参数值时就进入老年代|
|UseAdaptiveSizePolicy|动态调整Java堆中各个区域的大小以及进入老年代的年龄|
|HandlePromotionFailure|是否允许分配担保失败，即老年代的剩余空间不足以应付新生代的整个Eden和Survivor区的所有对象都存活的极端情况|
|ParallelGCThreads|设置并行GC时进行内存回收的线程数|
|GCTimeRatio|GC时间占总时间的比率，默认值为99，即允许1%的GC时间，仅在使用Parallel Scavenge收集器时生效|
|MaxGCPauseMillis|设置GC的最大停顿时间，仅在使用Parallel Scavenge收集器时生效|
|CMSInitiatingOccupancyFraction|设置CMS收集器在老年代空间被使用多少后触发垃圾收集，默认值为68%，仅在使用CMS收集器时生效|
|UseCMSCompactAtFullCollection|设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理，仅在使用CMS收集器时生效|
|CMSFullGCsBeforeCompaction|设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理，仅在使用CMS收集器时生效|
|PrintGCDetails|设置虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况|
