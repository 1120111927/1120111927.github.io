---
title: Java运行时内存区域
date: "2021-03-21"
description: Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。对于JDK7，Java虚拟机运行时数据区域包括：程序计数器、虚拟机栈、本地方法栈、堆、方法区。
tags: Java虚拟机内存模型, 程序计数器, 虚拟机栈, 本地方法栈, 堆, 方法区
---

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域，这些区域都有各自的用途，以及创建和销毁的时间。对于JDK7，Java虚拟机运行时数据区域包括：程序计数器、虚拟机栈、本地方法栈、堆、方法区。

内存溢出（out of memory）：是指程序运行所需内存超出系统内存

内存泄漏（memory leak）：是指程序中已动态分配的堆内存由于某种原因程序未释放或无法释放造成的系统内存的浪费

## 程序计数器（Program Counter Register）

程序计数器是线程私有内存，描述的是当前线程正在执行的虚拟机字节码指令的地址（对于Native方法，这个计数器值则为空（Undefined））。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

## 虚拟机栈（Virtual Machine Stacks）

Java虚拟机栈是线程私有内存，生命周期与线程相同，描述的是Java方法的内存模型。每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程。

局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、long、float、double）、对象引用（reference类型）和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间，其余的数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。

如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError异常；如果虚拟机栈动态扩展时无法申请到足够的内存，将抛出OutOfMemoryError异常。

## 本地方法栈（Native Method Stack）

本地方法栈是线程私有内存，生命周期与线程相同，描述的是Native方法的内存模型，也会抛出StackOverflowError和OutOfMemoryError异常。

## 堆（Heap）

Java堆是线程共享内存，在虚拟机启动时创建，用于存储对象实例（几乎所有的对象实例都在这里分配内存）。

Java堆是Java虚拟机所管理的内存中最大的一块，是垃圾收集器管理的主要区域，也被称为GC堆（Garbage Collected Heap）。对于分代收集算法，Java堆还可细分为：新生代和老年代，其中新生代又可细分为Eden空间、From Survivor空间、To Survivor空间。另外，Java堆中可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。

Java堆不需要连续的内存（物理上不连续，逻辑上连续），可以选择固定大小或者动态扩展。

如果Java堆无法满足内存分配需求（堆中没有内存完成实例分配，并且堆也无法再扩展），将抛出OutOfMemoryError异常。

## 方法区（Method Area）

方法区是线程共享内存，用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。HotSpot虚拟机把GC分代收集扩展至方法区，即使用永久代来实现方法区，所以对于HotSpot虚拟机，方法区也可称为永久代（Permanent Generation）。

方法区不需要连续的内存（物理上不连续，逻辑上连续），可以选择固定大小或者动态扩展，还可以不实现垃圾收集（方法区内存回收的目标主要是对常量池的回收和对类型的卸载）。

如果方法区无法满足内存分配需求，将抛出OutOfMemoryError异常。

### 运行时常量池（Runtime Constant Pool）

运行时常量池是方法区的一部分，用于存储Class文件中常量池（Constant Pool Table）里的内容（Class文件中的常量池用于存放编译器生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放）以及翻译出来的直接引用。

运行时常量池具备动态性，除了预置入Class文件中常量池的内容，运行期间也可以将新的常量放入池中（如String类的intern()方法）。

如果运行时常量池无法满足内存分配需求，将抛出OutOfMemory异常。

## 直接内存（Direct Memory）

直接内存不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域。JDK 1.4引入了NIO类（基于通道（channel）与缓冲区（Buffer）的I/O方式），它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作，避免了在Java堆和Native堆中来回复制数据，在一些场景中能显著提高性能。

直接内存的分配不会受到Java堆大小的限制，但是会受到系统内存（包括RAM以及SWAP区或者分页文件）大小以及处理器寻址空间的限制，当各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。
